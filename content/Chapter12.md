# 第十二章·错误处理

Errors are an inevitable part of software development. Handling them effectively is crucial for writing robust and reliable JavaScript code. This guide will walk you through the fundamentals of error handling in JavaScript, including why it's important, types of errors, and how to use the `try...catch` statement.



## Why Error Handling Matters

Error handling is essential for several reasons:
- **Graceful Recovery**: It allows your code to recover gracefully from unexpected issues and continue executing.
- **User Experience**: Effective error handling enhances the user experience by providing meaningful error messages.
- **Debugging**: Properly handled errors make debugging easier as you can pinpoint issues quickly.
- **Code Reliability**: Error handling ensures that your code is reliable and robust, reducing the risk of crashes.

## Types of Errors

JavaScript errors can be categorized into several types, including:
- **Syntax Errors**: Errors that occur due to incorrect syntax.
- **Runtime Errors**: Errors that happen during code execution.
- **Logic Errors**: Errors resulting from flawed logic in the code.

## Common Use Cases

Handling network requests that might fail.
Parsing and validating user input.
Managing third-party library errors.

## Advantages of Error Handling

Effective error handling offers several advantages:

- Prevents script termination.
- Allows for controlled handling of errors.
- Provides detailed error information for debugging.
- Enhances code reliability and user experience.


## Best Practices

To make the most of error handling, consider these best practices:

- Use specific error types whenever possible.
- Log errors for debugging purposes.
- Provide clear and user-friendly error messages.
- Handle errors as close to their source as possible.

## try...catch Error Handling:
One of the common error handling techniques is the `try...catch` block, which is described in the following sections.

* [try...catch](./try...-catch.md)
* [try...catch...finally](./try...catch...finally.md)

Error handling is a critical aspect of JavaScript development.
By understanding the types of errors, and following best practices, 
you can write more reliable and user-friendly applications.

# try... catch

Instead of halting the code execution, we can use the `try...catch` construct that allows catching errors without dying the script. The `try...catch` construct has two main blocks; `try` and then `catch`.&#x20;

```javascript
try {
  // code...
} catch (err) {
  // error handling
}
```

At first, the code in the `try` block is executed. If no errors are encountered then it skips the `catch` block. If an error occurs then the `try` execution is stopped, moving the control sequence to the `catch` block. The cause of the error is captured in `err` variable.

```javascript
try {
  // code...
  alert('Welcome to Learn JavaScript');  
  asdk; // error asdk variable is not defined
} catch (err) {
  console.log("Error has occurred");
}
```

{% hint style="warning" %}
`try...catch` works for runtime errors meaning that the code must be runnable and synchronous.
{% endhint %}

To throw a custom error, a `throw` statement can be used. The error object, that gets generated by errors has two main properties.&#x20;

* **name**:  error name
* **message**: details about the error&#x20;

{% hint style="info" %}
If we don't need an `error` message catch can be omitted.
{% endhint %}


# try...catch...finally

We can add one more construct to `try...catch` called `finally`, this code executes in all cases. i.e. after `try` when there is no error and after a `catch` in case of error. The syntax for `try ...catch...finally` is shown below.

```javascript
try {
   // try to execute the code
} catch (err) {
    // handle errors 
} finally {
   // execute always
}
```

Running real-world example code.

```javascript
try {
  alert( 'try' );
} catch (err) {
  alert( 'catch' );
} finally {
  alert( 'finally' );
}
```

In the above example, the `try` block is executed first which is then followed by `finally` as there are no errors.

{% exercise %}
Write a function `divideNumbers()` that takes two arguments numerator and denominator and returns the result of dividing numerator by denominator using following settings.

{% initial %}
function divideNumbers(numerator, denominator) {
    try {
      // try statement to divide numerator by denominator.
    } catch (error) {
      // print error message
    } finally {
      // print execution has finished
    }
   // return result
  }
  let answer = divideNumbers(10, 2);

{% solution %}
function divideNumbers(numerator, denominator) {
  let result;
    try {
      result = numerator / denominator;
    } catch (error) {
      console.error(`Error: ${error}`);
    } finally {
      console.log('Function finished executing');
    }
    return result;
  }
let answer = divideNumbers(10, 2);
{% validation %}
assert(answer == 5);

{% context %}
{% endexercise %}
